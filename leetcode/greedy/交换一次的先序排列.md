## 交换一次的先序排列

### 题目描述

给你一个正整数的数组 A（其中的元素不一定完全不同），请你返回可在 一次交换（交换两数字 A[i] 和 A[j] 的位置）后得到的、按字典序排列小于 A 的最大可能排列。

如果无法这么操作，就请返回原数组。

**示例 1：**

```java
输入：[3,2,1]
输出：[3,1,2]
解释：
交换 2 和 1
```

**示例 2：**

```java
输入：[1,1,5]
输出：[1,1,5]
解释： 
这已经是最小排列
```

**示例 3：**

```java
输入：[1,9,4,6,7]
输出：[1,7,4,6,9]
解释：
交换 9 和 7
```

**示例 4：**

```java
输入：[3,1,1,3]
输出：[1,3,1,3]
解释：
交换 1 和 3
```

**提示：**

```java
1 <= A.length <= 10000
1 <= A[i] <= 10000
```

[题目来源](https://leetcode-cn.com/problems/previous-permutation-with-one-swap)

### 解题思路

这道题不难，思路很快也就出来了，但是自己的思路一直不能成功AC，这让我思考是为什么，首先我一开始采用的是对数组进行从左到右扫描，但是仅仅是测试样例就卡住了，卡住的测试样例是`[3,2,1]`，我的方法得出结果是`[2,3,1]`，很崩溃，网上的方法对于字典序都是逆序扫描，除此之外和我的算法没有任何差别，这让我陷入了沉思....

首先我先去着手思考为什么别人的逆序能够成功，首先我们要先肯定的是，扫描的结果一定是左边的某一个值和右边比它小的最大值进行交换，右边的值无可厚非，但是要警惕的是左边的值在什么位置，后来才发现，原来解题的结果仅仅是逆序扫描的第一个逆序结果而已

### AC

```java
class Solution {
    public int[] prevPermOpt1(int[] A) {
        int n = A.length;
        for(int exptr1 = n - 1; exptr1 >= 0; exptr1--){
            int exptr2 = -1, max = -1;
            for(int j = exptr1 + 1; j < n; j++){
                if(A[exptr1] > A[j] && max < A[j]){
                    exptr2 = j;
                    max = A[j];
                }
            }
            if(max == -1){
                continue;
            }else{
                int t = A[exptr1];
                A[exptr1] = A[exptr2];
                A[exptr2] = t;
                break;
            }
        }
        return A;
    }
}
```

